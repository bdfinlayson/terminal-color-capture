#!/usr/bin/env ruby
require 'highline/import'
require 'sqlite3'

Dir["./app/**/*.rb"].each{|f| require f}
Dir["./lib/*.rb"].each{|f| require f}

# tput setaf 1
# tput setab 1
# tput bold
# tput reset
# export TERM=xterm-256color
# export PS1='\[$(tput setaf 7)\]\u@\[$(tput setaf 2)\]\h:\[$(tput setaf 4)\]'+
# '\w$(tput setaf 1)\]$(parse_git_branch)\[$(tput sgr0)\] $ '

# LSCOLORS
# The value of this variable describes what color to use for which attribute when colors
# are enabled with CLICOLOR.  This string is a concatenation of pairs of the format fb,
# where f is the foreground color and b is the background color.

# The color designators are as follows:

#    a     black
#    b     red
#    c     green
#    d     brown
#    e     blue
#    f     magenta
#    g     cyan
#    h     light grey
#    A     bold black, usually shows up as dark grey
#    B     bold red
#    C     bold green
#    D     bold brown, usually shows up as yellow
#    E     bold blue
#    F     bold magenta
#    G     bold cyan
#    H     bold light grey; looks like bright white
#    x     default foreground or background

# Note that the above are standard ANSI colors.  The actual display may differ depending
# on the color capabilities of the terminal in use.

# The order of the attributes are as follows:

#    1.   directory
#    2.   symbolic link
#    3.   socket
#    4.   pipe
#    5.   executable
#    6.   block special
#    7.   character special
#    8.   executable with setuid bit set
#    9.   executable with setgid bit set
#    10.  directory writable to others, with sticky bit
#    11.  directory writable to others, without sticky bit

# The default is "exfxcxdxbxegedabagacad", i.e. blue foreground and default background
# for regular directories, black foreground and red background for setuid executables,
# etc.

def accepted_ls_colors
    ['black','red','green','brown','blue','magenta','cyan','light grey', 'x']
end

choose do |menu|
  menu.prompt = "Hello, what would you like to do?\n"

  menu.choice(:CreateANewColorScheme) {
    color_scheme_answer_arr = ColorSchemeQuestionsController.ask_all_new_scheme
    new_color_scheme = ColorScheme.save(color_scheme_answer_arr,false)
    #Create New Color Scheme in DB
    ColorSchemeController.add(new_color_scheme)
  }
  menu.choice(:ActivateExistingColorScheme) {
    say(ColorSchemeController.table)
    if ColorScheme.count > 0
        activate_scheme = ColorSchemeQuestionsController.ask_which_color_scheme_activate
        if !activate_scheme.empty?
            ColorScheme.populate_bash_profile('1','12',false)
            say("Color scheme activated successfully!\n")
        end
    end
  }
  menu.choice(:EditExistingColorScheme) {
    say(ColorSchemeController.table)
    if ColorScheme.count > 0
        change_val_arr = ColorSchemeQuestionsController.ask_all_change_scheme
        #Update Color Scheme in DB
        ColorScheme.update(change_val_arr[0],change_val_arr[1],change_val_arr[2])
    end
  }
  menu.choice(:DeleteExistingColorScheme) {
    say(ColorSchemeController.table)
    if ColorScheme.count > 0
        delete_scheme = ColorSchemeQuestionsController.ask_which_color_scheme_delete
        if !delete_scheme.empty?
            id = ColorScheme.get_id(delete_scheme)
            ColorScheme.delete(id)
            say("Color scheme deleted successfully!\n")
        end
    end
  }
  menu.choice(:CreateLSColorProfile) {
    ls_name = ask("What would you like to call this LS Color Profile?",
        String){|scheme_name|

        }
    if ls_name.empty?
        say("You must enter a name for this ls color profile.\n")
        exit 0
    end
    directory_color = ask("What color text would you like directories to have?(use 'x' "+
        "for default)",
        accepted_ls_colors){|q|
        }
    symbolic_link_color = ask("What color text would you like symbolic links to have?(use 'x' for default)",
        accepted_ls_colors){|q|
        }
    socket_color = ask("What color text would you like sockets to have?(use 'x' for default)",
        accepted_ls_colors){|q|
        }
    pipe_color = ask("What color text would you like pipes to have?(use 'x' for default)",
        accepted_ls_colors){|q|
        }
    executable_color = ask("What color text would you like executables to have?(use 'x' for default)",
        accepted_ls_colors){|q|
        }
    block_special_color = ask("What color text would you like block specials to have?(use 'x' for default)",
        accepted_ls_colors){|q|
        }
    character_special_color = ask("What color text would you like character specials to have?(use 'x' for default)",
        accepted_ls_colors){|q|
        }
    executable_setuid_color = ask("What color text would you like executables with setuid bit sets to have?(use 'x' for default)",
        accepted_ls_colors){|q|
        }
    executable_setguid_color = ask("What color text would you like executables with setguid bit sets to have?(use 'x' for default)",
        accepted_ls_colors){|q|
        }
    others_directory_color = ask("What color text would you like directories writable to others, with sticky bit to have?(use 'x' for default)",
        accepted_ls_colors){|q|
        }
    others_directory_sticky_color = ask("What color text would you like directories writable to others, without sticky bit to have?(use 'x' for default)",
        accepted_ls_colors){|q|
        }
    say("New ls color profile created successfully!\n")
  }
  menu.choice(:ChangeLSColorProfile) {
    #show all existng ls color profiles
    edit_profile = ask("Which profile would you like to edit?")
    if !edit_profile.empty?
        #run "CreateLSColorProfile" menu, replacing existing variables
        say("LS Color profile edited successfully!\n")
    end
  }
  menu.choice(:DeleteLSColorProfile) {
    #show all existng color schemes
    delete_profile = ask("Which profile would you like to delete?"){|q|
        q.confirm = true
    }
    if !delete_profile.empty?
        #delete given profile name
        say("LS Color profile deleted successfully!\n")
    end
  }
  menu.choice(:Exit){
    say("See ya!")
    exit
  }
end